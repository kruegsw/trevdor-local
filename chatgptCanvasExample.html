<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Splendor (Canvas Minimal) – UI Skeleton</title>
  <style>
    :root { --bg:#0b0f14; --text:#e7eef7; --muted:#98a7ba; --border:#223041; }
    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; }
    body{
      background: radial-gradient(1100px 700px at 35% 10%, #182537, var(--bg));
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overflow:hidden;
    }
    header{
      height:56px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:0 14px;
      border-bottom:1px solid var(--border);
      background: rgba(18,26,35,.65);
      backdrop-filter: blur(8px);
    }
    header .sub{ color: var(--muted); font-size: 12px; }
    #wrap{
      height: calc(100% - 56px);
      display:flex;
      flex-direction: column;
    }
    canvas{
      width: 100%;
      height: 100%;
      display:block;
    }
  </style>
</head>
<body>
  <header>
    <div>
      <div style="font-weight:650; letter-spacing:.2px;">Splendor (Canvas Minimal)</div>
      <div class="sub">Click: tokens/cards • Enter: Confirm • Esc: Cancel • Space: End Turn</div>
    </div>
    <div class="sub" id="hud">—</div>
  </header>

  <div id="wrap">
    <canvas id="c"></canvas>
  </div>

  <script type="module">
    // ------------------------------------------------------------
    // Minimal Canvas UI skeleton:
    // - One render loop
    // - Simple hit-testing via stored rectangles
    // - No engine (yet): selection + mock state only
    // ------------------------------------------------------------

    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
    const hud = document.getElementById("hud");

    // Device pixel ratio scaling
    function resize() {
      const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
    }
    window.addEventListener("resize", resize);
    resize();

    // ---------- Mock data ----------
    const COLORS = ["white","blue","green","red","black","gold"];
    const COLOR_HEX = {
      white: "#d6dde8",
      blue:  "#4aa3ff",
      green: "#3ddc97",
      red:   "#ff5c70",
      black: "#606b7a",
      gold:  "#f6c453",
    };

    let state = {
      turn: { round: 1, currentPlayerIndex: 0 },
      bank: { white: 7, blue: 7, green: 7, red: 7, black: 7, gold: 5 },
      decksRemaining: { tier1: 36, tier2: 26, tier3: 16 },
      nobles: [
        { id: "N-01", points: 3, req: { red: 4, green: 4 } },
        { id: "N-02", points: 3, req: { blue: 4, black: 4 } },
        { id: "N-03", points: 3, req: { white: 4, blue: 4 } },
      ],
      market: {
        tier3: [
          { id: "T3-01", tier: 3, gem: "red",   points: 5, cost: { white: 3, blue: 3, green: 3, black: 3 } },
          { id: "T3-02", tier: 3, gem: "black", points: 4, cost: { red: 7 } },
          { id: "T3-03", tier: 3, gem: "green", points: 3, cost: { red: 3, blue: 3, white: 3 } },
          { id: "T3-04", tier: 3, gem: "blue",  points: 4, cost: { green: 6 } },
        ],
        tier2: [
          { id: "T2-01", tier: 2, gem: "white", points: 2, cost: { red: 2, green: 2, blue: 1 } },
          { id: "T2-02", tier: 2, gem: "blue",  points: 1, cost: { black: 3, white: 2 } },
          { id: "T2-03", tier: 2, gem: "red",   points: 2, cost: { green: 5 } },
          { id: "T2-04", tier: 2, gem: "green", points: 1, cost: { blue: 2, white: 2, red: 1 } },
        ],
        tier1: [
          { id: "T1-01", tier: 1, gem: "black", points: 0, cost: { white: 1, blue: 1, green: 1, red: 1 } },
          { id: "T1-02", tier: 1, gem: "green", points: 0, cost: { blue: 2 } },
          { id: "T1-03", tier: 1, gem: "red",   points: 1, cost: { black: 4 } },
          { id: "T1-04", tier: 1, gem: "white", points: 0, cost: { green: 3 } },
        ],
      },
      players: [
        { id:"P1", name:"Player 1", points:0 },
        { id:"P2", name:"Player 2", points:0 },
      ],
    };

    // UI-only selection
    const ui = {
      mode: "TAKE", // TAKE | BUY | RESERVE
      selectedTokens: new Set(),
      selectedCardId: null,
      selectedNobleId: null,
      message: "",
    };

    // Hit targets: {x,y,w,h,type,id,...}
    let hits = [];

    // ---------- Tiny drawing helpers ----------
    function clear() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function rect(x,y,w,h,r=12) {
      // rounded rect path
      ctx.beginPath();
      const rr = Math.min(r, w/2, h/2);
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y,   x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x,   y+h, rr);
      ctx.arcTo(x,   y+h, x,   y,   rr);
      ctx.arcTo(x,   y,   x+w, y,   rr);
      ctx.closePath();
    }

    function fillPanel(x,y,w,h) {
      rect(x,y,w,h,14);
      ctx.fillStyle = "rgba(18,26,35,.70)";
      ctx.fill();
      ctx.strokeStyle = "rgba(34,48,65,.85)";
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    function text(s, x, y, size=12, color="#e7eef7", align="left", baseline="alphabetic") {
      ctx.fillStyle = color;
      ctx.font = `${size}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
      ctx.textAlign = align;
      ctx.textBaseline = baseline;
      ctx.fillText(s, x, y);
    }

    function dot(x,y,r,color,stroke="rgba(255,255,255,.18)") {
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fillStyle = color;
      ctx.fill();
      ctx.strokeStyle = stroke;
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    function costLine(costObj) {
      const entries = Object.entries(costObj);
      if (!entries.length) return "free";
      return entries.map(([c,n]) => `${c[0].toUpperCase()}${n}`).join(" ");
    }

    // ---------- Layout + render ----------
    function render() {
      hits = [];
      clear();

      const W = canvas.getBoundingClientRect().width;
      const H = canvas.getBoundingClientRect().height;

      const pad = 14;
      const gap = 14;

      // 3 columns: bank/actions | board | players
      const leftW = Math.min(290, Math.floor(W * 0.27));
      const rightW = Math.min(320, Math.floor(W * 0.28));
      const centerW = Math.max(300, W - leftW - rightW - pad*2 - gap*2);

      const leftX = pad;
      const centerX = leftX + leftW + gap;
      const rightX = centerX + centerW + gap;
      const topY = pad;

      // Panels
      const leftH = H - pad*2;
      const rightH = H - pad*2;
      const centerH = H - pad*2;

      fillPanel(leftX, topY, leftW, leftH);
      fillPanel(centerX, topY, centerW, centerH);
      fillPanel(rightX, topY, rightW, rightH);

      // HUD
      const cp = state.players[state.turn.currentPlayerIndex];
      hud.textContent = `Round ${state.turn.round} • ${cp.name} • Mode ${ui.mode}`;

      // ----- LEFT: Bank + Actions -----
      text("BANK", leftX+12, topY+16, 12, "#98a7ba", "left", "top");
      const bankY = topY + 36;

      const cellGap = 10;
      const cellW = Math.floor((leftW - 12*2 - cellGap) / 2);
      const cellH = 44;

      COLORS.forEach((color, i) => {
        const col = i % 2;
        const row = Math.floor(i / 2);
        const x = leftX + 12 + col * (cellW + cellGap);
        const y = bankY + row * (cellH + 10);

        // token cell
        rect(x,y,cellW,cellH,12);
        const disabled = (state.bank[color] ?? 0) <= 0;
        const selected = ui.selectedTokens.has(color);

        ctx.fillStyle = selected ? "rgba(135,206,250,.12)" : "rgba(0,0,0,.10)";
        ctx.fill();
        ctx.strokeStyle = disabled ? "rgba(34,48,65,.6)" : "rgba(34,48,65,.9)";
        ctx.stroke();

        dot(x+16, y+cellH/2, 7, COLOR_HEX[color]);
        text(color, x+30, y+cellH/2, 12, disabled ? "rgba(231,238,247,.55)" : "#e7eef7", "left", "middle");
        text(String(state.bank[color] ?? 0), x+cellW-12, y+cellH/2, 12, "#e7eef7", "right", "middle");

        hits.push({ x,y,w:cellW,h:cellH, type:"token", color, disabled });
      });

      // Actions area
      const actY = bankY + 3*(cellH+10) + 20;
      text("ACTIONS", leftX+12, actY, 12, "#98a7ba", "left", "top");

      const btnY = actY + 24;
      const btnW = Math.floor((leftW - 12*2 - 10) / 2);
      const btnH = 42;

      const buttons = [
        { label:"Take",   type:"mode", value:"TAKE" },
        { label:"Buy",    type:"mode", value:"BUY" },
        { label:"Reserve",type:"mode", value:"RESERVE" },
        { label:"End Turn", type:"endturn" },
        { label:"Confirm",  type:"confirm" },
        { label:"Cancel",   type:"cancel" },
      ];

      buttons.forEach((b, idx) => {
        const col = idx % 2;
        const row = Math.floor(idx / 2);
        const x = leftX + 12 + col*(btnW+10);
        const y = btnY + row*(btnH+10);

        rect(x,y,btnW,btnH,12);
        const isMode = (b.type === "mode");
        const isActive = isMode && (ui.mode === b.value);
        ctx.fillStyle = isActive ? "rgba(135,206,250,.14)" : "rgba(0,0,0,.10)";
        ctx.fill();
        ctx.strokeStyle = "rgba(34,48,65,.9)";
        ctx.stroke();
        text(b.label, x+btnW/2, y+btnH/2, 12, "#e7eef7", "center", "middle");

        hits.push({ x,y,w:btnW,h:btnH, type:"button", btnType:b.type, value:b.value ?? null });
      });

      // Selection readout
      const selY = btnY + 3*(btnH+10) + 14;
      const tok = [...ui.selectedTokens].join(", ") || "none";
      const card = ui.selectedCardId || "none";
      text(`Selected tokens: ${tok}`, leftX+12, selY, 12, "#98a7ba", "left", "top");
      text(`Selected card: ${card}`, leftX+12, selY+18, 12, "#98a7ba", "left", "top");

      // ----- CENTER: Board (Nobles + Tiers) -----
      text("BOARD", centerX+12, topY+16, 12, "#98a7ba", "left", "top");

      // Nobles row
      const nobleY = topY + 36;
      text("Nobles", centerX+12, nobleY, 12, "#e7eef7", "left", "top");
      const nobleCardY = nobleY + 18;
      const nobleH = 86;
      const nobleGap = 12;
      const nobleW = Math.floor((centerW - 12*2 - 2*nobleGap) / 3);

      state.nobles.forEach((n, i) => {
        const x = centerX + 12 + i*(nobleW + nobleGap);
        const y = nobleCardY;
        rect(x,y,nobleW,nobleH,14);
        const selected = ui.selectedNobleId === n.id;
        ctx.fillStyle = selected ? "rgba(135,206,250,.12)" : "rgba(0,0,0,.10)";
        ctx.fill();
        ctx.strokeStyle = "rgba(34,48,65,.9)";
        ctx.stroke();

        dot(x+16, y+20, 7, COLOR_HEX.gold);
        text(`Noble`, x+30, y+20, 12, "#e7eef7", "left", "middle");
        text(String(n.points), x+nobleW-12, y+20, 12, "#e7eef7", "right", "middle");
        text(costLine(n.req), x+12, y+52, 12, "#98a7ba", "left", "middle");

        hits.push({ x,y,w:nobleW,h:nobleH, type:"noble", id:n.id });
      });

      // Market tiers
      const tiers = [
        { key:"tier3", label:"Tier 3", deckKey:"tier3" },
        { key:"tier2", label:"Tier 2", deckKey:"tier2" },
        { key:"tier1", label:"Tier 1", deckKey:"tier1" },
      ];

      const startY = nobleCardY + nobleH + 22;
      const tierGapY = 16;
      const rowLabelW = 74;
      const cardGap = 12;
      const cardH = 120;
      const cardW = Math.floor((centerW - 12*2 - rowLabelW - cardGap*3) / 4);

      tiers.forEach((t, ti) => {
        const y = startY + ti*(cardH + tierGapY);

        // label
        text(t.label, centerX+12, y+8, 12, "#e7eef7", "left", "top");
        text(`Deck ${state.decksRemaining[t.deckKey]}`, centerX+12, y+26, 11, "#98a7ba", "left", "top");

        // cards
        const baseX = centerX + 12 + rowLabelW;
        state.market[t.key].forEach((card, ci) => {
          const x = baseX + ci*(cardW + cardGap);

          rect(x,y,cardW,cardH,16);
          const selected = ui.selectedCardId === card.id;
          ctx.fillStyle = selected ? "rgba(135,206,250,.12)" : "rgba(0,0,0,.10)";
          ctx.fill();
          ctx.strokeStyle = "rgba(34,48,65,.9)";
          ctx.stroke();

          // top line: gem + points
          dot(x+16, y+20, 7, COLOR_HEX[card.gem]);
          text(card.gem, x+30, y+20, 12, "#e7eef7", "left", "middle");
          text(String(card.points), x+cardW-12, y+20, 12, "#e7eef7", "right", "middle");

          // cost text (minimal)
          text(costLine(card.cost), x+12, y+56, 12, "#98a7ba", "left", "middle");
          text(card.id, x+12, y+cardH-12, 10, "rgba(152,167,186,.75)", "left", "alphabetic");

          hits.push({ x,y,w:cardW,h:cardH, type:"card", id:card.id });
        });
      });

      // ----- RIGHT: Players -----
      text("PLAYERS", rightX+12, topY+16, 12, "#98a7ba", "left", "top");

      const py = topY + 36;
      const pH = 76;
      const pGap = 12;
      const pW = rightW - 24;

      state.players.forEach((p, i) => {
        const x = rightX + 12;
        const y = py + i*(pH + pGap);
        rect(x,y,pW,pH,16);

        const isCurrent = i === state.turn.currentPlayerIndex;
        ctx.fillStyle = isCurrent ? "rgba(135,206,250,.10)" : "rgba(0,0,0,.10)";
        ctx.fill();
        ctx.strokeStyle = isCurrent ? "rgba(135,206,250,.35)" : "rgba(34,48,65,.9)";
        ctx.stroke();

        text(p.name, x+12, y+22, 13, "#e7eef7", "left", "middle");
        text(`Pts ${p.points}`, x+pW-12, y+22, 12, "#e7eef7", "right", "middle");
        text(isCurrent ? "Current" : "", x+12, y+50, 12, "#98a7ba", "left", "middle");

        hits.push({ x,y,w:pW,h:pH, type:"player", id:p.id });
      });

      // subtle help text
      text("Tip: Canvas UI is just visuals + hit testing. Keep rules in a separate engine.", centerX+12, topY+centerH-14, 11, "rgba(152,167,186,.75)", "left", "alphabetic");
    }

    // ---------- Hit testing ----------
    function hitTest(px, py) {
      // iterate in reverse so top-most wins
      for (let i = hits.length - 1; i >= 0; i--) {
        const h = hits[i];
        if (px >= h.x && px <= h.x + h.w && py >= h.y && py <= h.y + h.h) return h;
      }
      return null;
    }

    // ---------- Input ----------
    canvas.addEventListener("pointerdown", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const h = hitTest(x,y);
      if (!h) return;

      if (h.type === "token") {
        if (ui.mode !== "TAKE") return;
        if (h.disabled) return;

        if (ui.selectedTokens.has(h.color)) ui.selectedTokens.delete(h.color);
        else {
          // Minimal UI rule: allow up to 3 selected
          if (ui.selectedTokens.size >= 3) return;
          ui.selectedTokens.add(h.color);
        }
        render();
        return;
      }

      if (h.type === "card") {
        ui.selectedCardId = (ui.selectedCardId === h.id) ? null : h.id;
        render();
        return;
      }

      if (h.type === "noble") {
        ui.selectedNobleId = (ui.selectedNobleId === h.id) ? null : h.id;
        render();
        return;
      }

      if (h.type === "button") {
        if (h.btnType === "mode") {
          ui.mode = h.value;
          ui.selectedTokens.clear();
          ui.selectedCardId = null;
          ui.selectedNobleId = null;
          render();
          return;
        }
        if (h.btnType === "cancel") {
          ui.selectedTokens.clear();
          ui.selectedCardId = null;
          ui.selectedNobleId = null;
          render();
          return;
        }
        if (h.btnType === "confirm") {
          console.log("CONFIRM (UI only):", {
            mode: ui.mode,
            tokens: [...ui.selectedTokens],
            cardId: ui.selectedCardId,
            nobleId: ui.selectedNobleId
          });
          ui.selectedTokens.clear();
          ui.selectedCardId = null;
          ui.selectedNobleId = null;
          render();
          return;
        }
        if (h.btnType === "endturn") {
          // UI-only: rotate player
          const last = state.players.length - 1;
          const nextIdx = (state.turn.currentPlayerIndex + 1) % state.players.length;
          state.turn.round = (state.turn.currentPlayerIndex === last) ? state.turn.round + 1 : state.turn.round;
          state.turn.currentPlayerIndex = nextIdx;

          ui.selectedTokens.clear();
          ui.selectedCardId = null;
          ui.selectedNobleId = null;
          render();
          return;
        }
      }
    });

    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape") {
        ui.selectedTokens.clear();
        ui.selectedCardId = null;
        ui.selectedNobleId = null;
        render();
      }
      if (e.key === "Enter") {
        console.log("CONFIRM (UI only):", {
          mode: ui.mode,
          tokens: [...ui.selectedTokens],
          cardId: ui.selectedCardId,
          nobleId: ui.selectedNobleId
        });
        ui.selectedTokens.clear();
        ui.selectedCardId = null;
        ui.selectedNobleId = null;
        render();
      }
      if (e.key === " ") {
        e.preventDefault();
        const last = state.players.length - 1;
        const nextIdx = (state.turn.currentPlayerIndex + 1) % state.players.length;
        state.turn.round = (state.turn.currentPlayerIndex === last) ? state.turn.round + 1 : state.turn.round;
        state.turn.currentPlayerIndex = nextIdx;
        render();
      }
    });

    // Initial render
    render();
  </script>
</body>
</html>
